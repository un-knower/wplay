 

### reids的抢购  

利用watch和redis的事务特性实现了基于redis的抢购  

### 原理  

利用watch和redis的multi来保证操作的原子性，避免超卖的情况.  

并且提供了spikeUtils，这个类中randomAccess方法可以作为上游请求的拦截方式.     

这里我们推荐的方式是每次秒杀活动中先在上游的请求中拦截大部分的请求.

可以通过修改spikeUtils的穿透率来调节请求穿透到真实的redis操作的比例.    

这样可以极大程度的进行缓冲限制.

### 抢购的实现  

1. 首先判断成功抢购的人的数量是否超出限额  
2. 判断是否已经买过,防止同一类产品卖给同一个人多次  
3. 开启cas和事务  
4. 成功抢购人数+1  
5. 抢购队列增加用户  
6. 判断执行结果    
    
### 使用方式  

配置spikeUtils的spikeMaxGoodNumber参数,来告诉程序最大的购买量,
这里推荐使用zookeeper来进行这个热配置的动态管理.

调用spikeUtils的spike方法,他会返回一个布尔值,告诉你是否抢购成功.  

### TODOList

完善测试用例  

