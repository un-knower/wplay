package com.wplay.core.jdbc

import java.sql.{Connection, DriverManager, ResultSet, Savepoint}
import java.util
import java.util.Properties
import java.util.concurrent.{ConcurrentHashMap, Executor}

import com.typesafe.config.ConfigFactory
import org.apache.commons.pool2.impl.{DefaultPooledObject, GenericObjectPool, GenericObjectPoolConfig}
import org.apache.commons.pool2.{BasePooledObjectFactory, PooledObject}
import org.slf4j.{Logger, LoggerFactory}

import scala.collection.JavaConversions._
import scala.util.Try

/**
  * JDBC 连接池
  */
object JDBCConnPool {

  val logger: Logger = LoggerFactory.getLogger(getClass)

  @transient
  private lazy val pools: ConcurrentHashMap[String, GenericObjectPool[JdbcProxy]] = new ConcurrentHashMap[String, GenericObjectPool[JdbcProxy]]()

  private lazy val config = ConfigFactory.load()

  def connect(driverName: String): InkeConnection = {
    InkeConnection(pools.getOrElseUpdate(driverName, createPool(driverName)))
  }

  /**
    *
    * @param driverName
    * @return
    */
  def getParams(driverName: String) = {
    val driver = config.getString(s"jdbc.$driverName.driver")
    val connurl = config.getString(s"jdbc.$driverName.connurl")
    val username = config.getString(s"jdbc.$driverName.username")
    val password = config.getString(s"jdbc.$driverName.password")
    (driver, connurl, username, password)
  }

  /**
    *
    * @param driverName
    * @return
    */
  private def createPool(driverName: String): GenericObjectPool[JdbcProxy] = {

    val (driver, connurl, username, password) = getParams(driverName)

    Class.forName(driver)

    val pooledFactory = new PooledJdbcClientFactory(connurl, username, password)

    val poolConfig = {
      val config_ = new GenericObjectPoolConfig
      config_.setMaxTotal(Try(config.getInt(s"jdbc.$driverName.maxtotal")).getOrElse(10))
      config_.setMaxIdle(Try(config.getInt(s"jdbc.$driverName.maxidle")).getOrElse(8))
      config_.setMaxWaitMillis(Try(config.getLong(s"jdbc.$driverName.maxwaitmillis")).getOrElse(1000))
      config_.setTestWhileIdle(Try(config.getBoolean(s"jdbc.$driverName.testwhileidle")).getOrElse(false))
      config_.setTimeBetweenEvictionRunsMillis(Try(config.getLong(s"jdbc.$driverName.timebetweenevictionrunsmillis")).getOrElse(10000))
      config_
    }
    //返回一个对象池
    new GenericObjectPool[JdbcProxy](pooledFactory, poolConfig)
  }

  def main(args: Array[String]): Unit = {

    val conn = JDBCConnPool.connect("druid")
    val stmt = conn.createStatement()

    val sql = "select count(1) from druid_source_kfk_applog_v1 WHERE __time >= CURRENT_TIMESTAMP - INTERVAL '1' HOUR"
    val resultSet = stmt.executeQuery(sql)


    result(resultSet).foreach(println)

  }

  def result(resultSet: ResultSet): List[Any] = {
    val md = resultSet.getMetaData

    val colNames = (1 to md.getColumnCount).map(md.getColumnName)


    Iterator.continually((resultSet.next(), resultSet)).takeWhile(_._1)
      .map(_._2)
      .map(rs => {
        val map = colNames.map(name => name -> rs.getObject(name)).toMap
        map
      }).toList
  }

}


case class InkeConnection(pool: GenericObjectPool[JdbcProxy]) extends Connection {


  private lazy val jdbcProxy = pool.borrowObject()
  private lazy val conn = jdbcProxy.conn

  override def commit(): Unit = conn.commit()

  override def getHoldability = conn.getHoldability

  override def setCatalog(catalog: String): Unit = conn.setCatalog(catalog)

  override def setHoldability(holdability: Int): Unit = conn.setHoldability(holdability)

  override def prepareStatement(sql: String) = conn.prepareStatement(sql)

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int) = conn.prepareStatement(sql, resultSetType, resultSetConcurrency)

  override def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = conn.prepareStatement(sql: String, resultSetType, resultSetConcurrency, resultSetHoldability)

  override def prepareStatement(sql: String, autoGeneratedKeys: Int) = conn.prepareStatement(sql, autoGeneratedKeys)

  override def prepareStatement(sql: String, columnIndexes: Array[Int]) = conn.prepareStatement(sql, columnIndexes)

  override def prepareStatement(sql: String, columnNames: Array[String]) = conn.prepareStatement(sql, columnNames)

  override def createClob() = conn.createClob

  override def setSchema(schema: String): Unit = conn.setSchema(schema)

  override def setClientInfo(name: String, value: String): Unit = conn.setClientInfo(name, value)

  override def setClientInfo(properties: Properties): Unit = conn.setClientInfo(properties)

  override def createSQLXML() = conn.createSQLXML

  override def getCatalog = conn.getCatalog

  override def createBlob() = conn.createBlob

  override def createStatement() = conn.createStatement

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int) = conn.createStatement(resultSetType, resultSetConcurrency)

  override def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = conn.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability)

  override def abort(executor: Executor): Unit = conn.abort(executor)

  override def setAutoCommit(autoCommit: Boolean): Unit = conn.setAutoCommit(autoCommit)

  override def getMetaData = conn.getMetaData

  override def setReadOnly(readOnly: Boolean): Unit = conn.setReadOnly(readOnly)

  override def prepareCall(sql: String) = conn.prepareCall(sql)

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int) = conn.prepareCall(sql, resultSetType, resultSetConcurrency)

  override def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = conn.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability)

  override def setTransactionIsolation(level: Int): Unit = conn.setTransactionIsolation(level)

  override def getWarnings = conn.getWarnings

  override def releaseSavepoint(savepoint: Savepoint): Unit = conn.releaseSavepoint(savepoint)

  override def nativeSQL(sql: String) = conn.nativeSQL(sql)

  override def isReadOnly = conn.isReadOnly

  override def createArrayOf(typeName: String, elements: Array[AnyRef]) = conn.createArrayOf(typeName, elements)

  override def setSavepoint() = conn.setSavepoint()

  override def setSavepoint(name: String) = conn.setSavepoint(name)

  override def close(): Unit = {
    pool.returnObject(jdbcProxy)
  }

  override def createNClob() = conn.createNClob

  override def rollback(): Unit = conn.rollback()

  override def rollback(savepoint: Savepoint): Unit = conn.rollback(savepoint)

  override def setNetworkTimeout(executor: Executor, milliseconds: Int): Unit = conn.setNetworkTimeout(executor, milliseconds)

  override def setTypeMap(map: util.Map[String, Class[_]]): Unit = conn.setTypeMap(map)

  override def isValid(timeout: Int) = conn.isValid(timeout)

  override def getAutoCommit = conn.getAutoCommit

  override def clearWarnings(): Unit = conn.clearWarnings()

  override def getSchema = conn.getSchema

  override def getNetworkTimeout = conn.getNetworkTimeout

  override def isClosed = conn.isClosed

  override def getTransactionIsolation = conn.getTransactionIsolation

  override def createStruct(typeName: String, attributes: Array[AnyRef]) = conn.createStruct(typeName, attributes)

  override def getClientInfo(name: String) = conn.getClientInfo(name)

  override def getClientInfo = conn.getClientInfo

  override def getTypeMap = conn.getTypeMap

  override def unwrap[T](iface: Class[T]) = conn.unwrap(iface)

  override def isWrapperFor(iface: Class[_]) = conn.isWrapperFor(iface)
}

/**
  * MySQL客户端代理对象
  *
  * @param jdbcUrl      JDBC URL
  * @param jdbcUser     JDBC 用户
  * @param jdbcPassword JDBC 密码
  */
case class JdbcProxy(jdbcUrl: String, jdbcUser: String, jdbcPassword: String) {


  // 客户端连接对象
  lazy val conn = DriverManager.getConnection(jdbcUrl, jdbcUser, jdbcPassword)

  // 关闭客户端
  def shutdown(): Unit = conn.close()
}

/**
  * 继承一个基础的连接池，需要提供池化的对象类型
  *
  * @param jdbcUrl      JDBC URL
  * @param jdbcUser     JDBC USER
  * @param jdbcPassword JDBC PASSWORD
  */
class PooledJdbcClientFactory(jdbcUrl: String, jdbcUser: String, jdbcPassword: String) extends BasePooledObjectFactory[JdbcProxy] with Serializable {

  // 用于池来创建对象
  override def create(): JdbcProxy = JdbcProxy(jdbcUrl, jdbcUser, jdbcPassword)

  // 用于池来包装对象
  override def wrap(obj: JdbcProxy): PooledObject[JdbcProxy] = new DefaultPooledObject(obj)

  // 用于池来销毁对象
  override def destroyObject(p: PooledObject[JdbcProxy]): Unit = {
    p.getObject.shutdown()
    super.destroyObject(p)
  }

}